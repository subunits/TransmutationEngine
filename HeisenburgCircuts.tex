\documentclass[12pt,a4paper]{article}

% --- Packages ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{caption}

% --- Document Setup ---
\geometry{margin=1in}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=cyan}

% --- Code Highlighting Setup ---
\definecolor{haskellpurple}{rgb}{0.5, 0, 0.5}
\definecolor{haskellblue}{rgb}{0, 0, 0.7}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstset{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{gray},
    keywordstyle=\color{haskellpurple}\bfseries,
    numberstyle=\tiny\color{gray},
    stringstyle=\color{haskellblue},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Haskell,
    frame=single
}

% --- Title ---
\title{Modular Emulation of Non-Commutative Quantum Logic: A Three-Stage Functional Pipeline}
\author{Simulated Hardware Systems Laboratory}
\date{February 12, 2026}

\begin{document}

\maketitle

\begin{abstract}
This paper presents a modular hardware emulator implemented in Haskell. We demonstrate a decoupled pipeline simulating a Heisenberg commutator $[p, q]$ through quaternion algebra. By utilizing a file-based data bus, the system successfully subjects the quantum state to unitary time-evolution while maintaining constant amplitude, providing a robust architecture for non-commutative logic simulation.
\end{abstract}

\section{Introduction}
Modern quantum-classical hybrid systems require a rigorous separation of signal control and logical processing. This project implements a functional hardware model consisting of a Control Unit (Clock), an Arithmetic Logic Unit (Heisenberg), and a Measurement Unit (Observer).

\section{Mathematical Framework}
The simulation is grounded in Hamilton's quaternions ($\mathbb{H}$). The non-commutativity of the $\mathbf{i, j, k}$ basis is used to model the fundamental commutation relation of quantum mechanics.

\subsection{Operator Definitions}
We define the conjugate variables $p$ and $q$ as pure imaginary units:
\begin{equation}
p = \mathbf{i}, \quad q = \mathbf{j}
\end{equation}
The resulting commutator $[p, q]$ is calculated as:
\begin{equation}
[p, q] = pq - qp = \mathbf{k} - (-\mathbf{k}) = 2\mathbf{k}
\end{equation}

\subsection{Unitary Evolution}
A rotation operator $R(t)$, representing a unitary gate, is defined as:
\begin{equation}
R(t) = \cos\left(\frac{t}{2}\right) + \mathbf{i}\sin\left(\frac{t}{2}\right)
\end{equation}
The final state $\Psi$ is the Hamilton product $R(t) \cdot [p, q]$.

\section{System Architecture}
The system architecture follows a linear pipeline (Figure 1). Data is persisted between stages using flat text-file registers to simulate a hardware bus.



\begin{enumerate}
    \item \textbf{The Clock}: Generates the unitary instruction based on user-defined temporal parameters.
    \item \textbf{The Heisenberg Unit}: A stateless processor that interprets bus instructions and performs non-commutative multiplication.
    \item \textbf{The Observer}: A telemetry tool that calculates the Euclidean norm $\| \Psi \|$ to verify conservation of information.
\end{enumerate}

\section{Results and Discussion}
Table 1 illustrates the register shift observed at $t = \pi$. The results indicate a 100\% transfer of signal from the $k$-register to the $j$-register, typical of a 180-degree phase rotation in the imaginary plane.

\begin{table}[h]
\centering
\begin{tabular}{@{}ccc@{}}
\toprule
\textbf{Register} & \textbf{Initial (2.0k)} & \textbf{Final (Phase Shifted)} \\ \midrule
Real ($r$)        & 0.0                    & 0.0                          \\
Imag ($i$)        & 0.0                    & 0.0                          \\
Imag ($j$)        & 0.0                    & -2.0                         \\
Imag ($k$)        & 2.0                    & 0.0                          \\ \bottomrule
\end{tabular}
\caption{Register Transformation across the Hardware Bus}
\end{table}

\section{Conclusion}
The successful execution of the modular pipeline confirms that functional languages like Haskell are ideally suited for emulating non-linear quantum logic. Future iterations will expand the bus to support multi-qubit entanglement simulations.

\begin{thebibliography}{9}
\bibitem{hamilton} W. R. Hamilton, \textit{Elements of Quaternions}, 1866.
\bibitem{heisenberg} W. Heisenberg, \textit{The Physical Principles of the Quantum Theory}, 1930.
\end{thebibliography}

\newpage
\appendix
\section{Appendix: Full Haskell Source Code}

\subsection{Clock.hs}
\begin{lstlisting}
module Main where
import Text.Read (readMaybe)

main :: IO ()
main = do
    putStrLn "ENTER TIME STEP:"
    input <- getLine
    let raw = if not (null input) && head input == '.' then "0" ++ input else input
    case readMaybe raw :: Maybe Double of
        Just t -> do
            let (r, i) = (cos(t/2), sin(t/2))
            writeFile "operator_bus.txt" (unwords $ map show [r, i, 0.0, 0.0])
            putStrLn "Signal Generator: Rotation pulse pushed."
        Nothing -> putStrLn "Error: Invalid Input."
\end{lstlisting}

\subsection{Heisenberg.hs}
\begin{lstlisting}
module Main where

data Q = Q Double Double Double Double deriving Show

instance Num Q where
    (Q a1 b1 c1 d1) * (Q a2 b2 c2 d2) = Q
        (a1*a2 - b1*b2 - c1*c2 - d1*d2)
        (a1*b2 + b1*a2 + c1*d2 - d1*c2)
        (a1*c2 - b1*d2 + c1*a2 + d1*b2)
        (a1*d2 + b1*c2 - c1*b2 + d1*a2)
    (Q a b c d) + (Q w x y z) = Q (a+w) (b+x) (c+y) (d+z)
    (Q a b c d) - (Q w x y z) = Q (a-w) (b-x) (c-y) (d-z)
    fromInteger n = Q (fromInteger n) 0 0 0
    abs (Q a b c d) = Q (sqrt(a*a + b*b + c*c + d*d)) 0 0 0
    signum (Q a b c d) = let m = sqrt(a*a+b*b+c*c+d*d) in Q (a/m) (b/m) (c/m) (d/m)

main :: IO ()
main = do
    instr <- readFile "operator_bus.txt"
    let [r, i, j, k] = map read (words instr) :: [Double]
    let rot = Q r i j k
    let (p, q) = (Q 0 1 0 0, Q 0 0 1 0)
    let gap = (p * q) - (q * p)
    let (Q r2 i2 j2 k2) = rot * gap
    writeFile "bus.txt" (unwords $ map show [r2, i2, j2, k2])
\end{lstlisting}

\subsection{Observer.hs}
\begin{lstlisting}
module Main where

main :: IO ()
main = do
    dat <- readFile "bus.txt"
    let [r, i, j, k] = map read (words dat) :: [Double]
    let amp = sqrt (r*r + i*i + j*j + k*k)
    putStrLn $ "--- SENSOR READING ---\nMeasured Amplitude: " ++ show amp
\end{lstlisting}

\end{document}
