\documentclass[12pt,a4paper]{article}

% --- Packages ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{caption}

% --- Document Setup ---
\geometry{margin=1in}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=cyan}

% --- Code Highlighting Setup ---
\definecolor{haskellpurple}{rgb}{0.5, 0, 0.5}
\definecolor{haskellblue}{rgb}{0, 0, 0.7}
\definecolor{bgcode}{rgb}{0.97, 0.97, 0.97}

\lstset{
    backgroundcolor=\color{bgcode},
    basicstyle=\ttfamily\small,
    breaklines=true,
    captionpos=b,
    commentstyle=\color{gray},
    keywordstyle=\color{haskellpurple}\bfseries,
    stringstyle=\color{haskellblue},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    tabsize=2,
    language=Haskell,
    frame=single,
    rulecolor=\color{black!20}
}

% --- Title ---
\title{Modular Emulation of Non-Commutative Quantum Logic: A Three-Stage Functional Pipeline}
\author{Simulated Hardware Systems Laboratory}
\date{February 12, 2026}

\begin{document}

\maketitle

\begin{abstract}
This paper outlines the implementation of a functional hardware emulator designed to model Heisenberg-style non-commutative logic. Using Haskell, we demonstrate a decoupled three-stage pipeline where data transitions through a simulated hardware bus. The system successfully validates the preservation of unitary amplitude across phase-shifted registers using quaternion Hamilton products.
\end{abstract}

\section{Introduction}
In quantum computational architectures, the separation of signal generation, logic processing, and measurement is fundamental. This project simulates these discrete hardware components via a file-based I/O system, ensuring that the mathematical state remains consistent throughout asynchronous execution cycles. By leveraging the algebraic properties of quaternions, we create a robust environment for testing non-commutative operators.

\section{Methodology}
The simulator utilizes Quaternions ($\mathbb{H}$) to represent the hardware registers. The advantage of this approach is the inherent non-commutativity of the algebra, which directly mirrors the Heisenberg uncertainty relation $[p, q]$.

\subsection{The Commutator Logic}
We define the primary registers as pure imaginary units:
\begin{align}
p &= 0 + 1\mathbf{i} + 0\mathbf{j} + 0\mathbf{k} \\
q &= 0 + 0\mathbf{i} + 1\mathbf{j} + 0\mathbf{k}
\end{align}
The logic unit calculates the gap (the commutator):
\begin{equation}
[p, q] = pq - qp = (\mathbf{k}) - (-\mathbf{k}) = 2\mathbf{k}
\end{equation}

\subsection{Unitary Rotations}
The clock generates a rotation operator $R$ for a time-step $t$:
\begin{equation}
R(t) = \cos\left(\frac{t}{2}\right) + \mathbf{i}\sin\left(\frac{t}{2}\right)
\end{equation}
The final bus state is the result of the Hamilton product:
\begin{equation}
\Psi_{out} = R(t) \cdot [p, q]
\end{equation}

\section{Architecture}
The hardware is abstracted into three functional modules. This modularity allows for "hot-swapping" logic units without reconfiguring the signal generator.



\begin{itemize}
    \item \textbf{Clock.hs}: Acts as the Control Unit (CU), providing the timing signal.
    \item \textbf{Heisenberg.hs}: The Arithmetic Logic Unit (ALU), responsible for non-commutative operations.
    \item \textbf{Observer.hs}: The I/O Unit, responsible for telemetry and state verification.
\end{itemize}

\section{Data and Results}
Experimental runs with $t = \pi$ demonstrate that while the state undergoes a full phase transition from the $\mathbf{k}$ register to the $\mathbf{j}$ register, the Euclidean norm (Amplitude) remains invariant at 2.0.

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Register} & \textbf{Baseline ($t=0$)} & \textbf{Evolved ($t=\pi$)} \\ \midrule
Real ($r$)        & 0.0                       & 0.0                        \\
Imag ($i$)        & 0.0                       & 0.0                        \\
Imag ($j$)        & 0.0                       & -2.0                       \\
Imag ($k$)        & 2.0                       & 0.0                        \\ \midrule
\textbf{Amplitude} & \textbf{2.0}              & \textbf{2.0}               \\ \bottomrule
\end{tabular}
\caption{Comparison of Bus States during Time Evolution}
\end{table}

\section{Conclusion}
This simulation confirms that file-based modularity is a viable pathway for complex quantum emulation. By separating the mathematical logic from the measurement and signal generation, we have created a scalable framework for future tests involving environmental decoherence and stochastic noise injection.

\begin{thebibliography}{9}
\bibitem{hamilton} W. R. Hamilton, \textit{Elements of Quaternions}, Longmans, Green \& Co., 1866.
\bibitem{heisenberg} W. Heisenberg, \textit{The Physical Principles of the Quantum Theory}, University of Chicago Press, 1930.
\bibitem{haskell} Simon Thompson, \textit{Haskell: The Craft of Functional Programming}, Addison-Wesley, 2011.
\end{thebibliography}

\newpage
\appendix
\section{Source Code Appendix}

\subsection{Clock.hs}
\begin{lstlisting}
module Main where
import Text.Read (readMaybe)

rotationOperator :: Double -> (Double, Double, Double, Double)
rotationOperator t = (cos(t/2), sin(t/2), 0, 0)

main :: IO ()
main = do
    putStrLn "Enter time step (t):"
    input <- getLine
    let raw = if head input == '.' then "0" ++ input else input
    case readMaybe raw of
        Just t -> do
            let (r, i, j, k) = rotationOperator t
            writeFile "operator_bus.txt" (unwords $ map show [r,i,j,k])
            putStrLn "Signal Generator: Rotation pulse pushed."
        Nothing -> putStrLn "Error: Invalid Input."
\end{lstlisting}

\subsection{Heisenberg.hs}
\begin{lstlisting}
module Main where

data Q = Q Double Double Double Double deriving Show

instance Num Q where
    (Q a1 b1 c1 d1) * (Q a2 b2 c2 d2) = Q
        (a1*a2 - b1*b2 - c1*c2 - d1*d2)
        (a1*b2 + b1*a2 + c1*d2 - d1*c2)
        (a1*c2 - b1*d2 + c1*a2 + d1*b2)
        (a1*d2 + b1*c2 - c1*b2 + d1*a2)
    (Q a b c d) - (Q w x y z) = Q (a-w) (b-x) (c-y) (d-z)
    fromInteger n = Q (fromInteger n) 0 0 0
    negate (Q a b c d) = Q (-a) (-b) (-c) (-d)
    (+) (Q a b c d) (Q w x y z) = Q (a+w) (b+x) (c+y) (d+z)
    abs = undefined; signum = undefined

main :: IO ()
main = do
    instr <- readFile "operator_bus.txt"
    let [r, i, j, k] = map read (words instr)
    let rot = Q r i j k
    let p = Q 0 1 0 0
    let q = Q 0 0 1 0
    let gap = (p * q) - (q * p)
    let (Q r2 i2 j2 k2) = rot * gap
    writeFile "bus.txt" (unwords $ map show [r2, i2, j2, k2])
\end{lstlisting}

\subsection{Observer.hs}
\begin{lstlisting}
module Main where

main :: IO ()
main = do
    dat <- readFile "bus.txt"
    let [r, i, j, k] = map read (words dat) :: [Double]
    let amp = sqrt (r*r + i*i + j*j + k*k)
    putStrLn $ "--- SENSOR READING ---\nAmplitude: " ++ show amp
\end{lstlisting}

\end{document}
